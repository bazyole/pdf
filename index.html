<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Split PDF (client-side)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; background:#0b0f19; color:#e7eefc; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 28px 18px 60px; }
    h1 { font-size: 22px; margin: 0 0 14px; }
    .card {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    label { display:block; font-weight:600; margin: 12px 0 8px; }
    input[type="file"] { width:100%; }
    input[type="text"], input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color:#e7eefc;
      outline:none;
    }
    .row { display:flex; gap: 12px; flex-wrap: wrap; }
    .col { flex:1 1 280px; }
    button {
      margin-top: 14px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(122,162,247,.22);
      color:#e7eefc;
      font-weight:700;
      cursor:pointer;
    }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .hint { opacity:.85; font-size: 13px; line-height: 1.35; }
    .ok { color: #6ee7b7; }
    .warn { color: #fbbf24; }
    .err { color: #fb7185; }
    pre {
      margin: 12px 0 0;
      padding: 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      overflow:auto;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
    .footer { margin-top: 14px; opacity:.75; font-size: 12px; }
    a { color:#a5b4fc; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Outil HTML — Split PDF (découper un PDF)</h1>

    <div class="card">
      <label>1) Choisir un PDF</label>
      <input id="pdfFile" type="file" accept="application/pdf" />

      <div class="row">
        <div class="col">
          <label>2) Mode de découpe</label>
          <div class="hint">
            <b>Option A — Plages</b> : ex. <code>1-3,5,7-9</code> (un fichier par plage / page isolée).<br>
            <b>Option B — Par taille fixe</b> : ex. “10 pages” → 1-10, 11-20, etc.
          </div>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Option A — Plages (prioritaire si rempli)</label>
          <input id="ranges" type="text" placeholder="Ex: 1-3,5,7-9" />
          <div class="hint">Pages 1-indexées (la première page = 1). Espaces autorisés.</div>
        </div>
        <div class="col">
          <label>Option B — Découper tous les N pages</label>
          <input id="chunkSize" type="number" min="1" step="1" placeholder="Ex: 10" />
          <div class="hint">Utilisé uniquement si le champ “Plages” est vide.</div>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Nom de base des fichiers</label>
          <input id="baseName" type="text" placeholder="Ex: document" />
          <div class="hint">Les fichiers seront nommés <code>base_p001-003.pdf</code>, etc.</div>
        </div>
        <div class="col">
          <label>Sortie</label>
          <div class="hint">
            Les PDFs générés sont regroupés dans un <b>ZIP</b> téléchargé automatiquement.
          </div>
        </div>
      </div>

      <button id="btnSplit" disabled>Découper & Télécharger le ZIP</button>

      <pre id="log" aria-live="polite"></pre>

      <div class="footer">
        Libs utilisées côté navigateur : <a href="https://pdf-lib.js.org/" target="_blank" rel="noreferrer">pdf-lib</a> + <a href="https://stuk.github.io/jszip/" target="_blank" rel="noreferrer">JSZip</a>.
      </div>
    </div>
  </div>

  <!-- pdf-lib -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- jszip -->
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const pdfFileEl = $("pdfFile");
    const rangesEl = $("ranges");
    const chunkSizeEl = $("chunkSize");
    const baseNameEl = $("baseName");
    const btnSplitEl = $("btnSplit");
    const logEl = $("log");

    let pdfBytes = null;
    let pdfName = "document";

    function log(msg, cls="") {
      const prefix = cls ? `[${cls.toUpperCase()}] ` : "";
      logEl.textContent += prefix + msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() { logEl.textContent = ""; }

    function sanitizeBaseName(name) {
      const s = (name || "").trim();
      if (!s) return "document";
      return s.replace(/[<>:"/\\|?*\u0000-\u001F]/g, "_").slice(0, 80);
    }

    function pad3(n) { return String(n).padStart(3, "0"); }

    // Parse "1-3,5,7-9" into array of [start,end] (1-indexed)
    function parseRanges(input, pageCount) {
      const text = (input || "").trim();
      if (!text) return null;

      const parts = text.split(",").map(s => s.trim()).filter(Boolean);
      if (parts.length === 0) return null;

      const ranges = [];
      for (const p of parts) {
        const m = p.match(/^(\d+)(?:\s*-\s*(\d+))?$/);
        if (!m) throw new Error(`Plage invalide: "${p}" (format attendu: 1-3,5,7-9)`);
        let a = parseInt(m[1], 10);
        let b = m[2] ? parseInt(m[2], 10) : a;

        if (a < 1 || b < 1) throw new Error(`Pages doivent être >= 1 (reçu: "${p}")`);
        if (a > b) [a, b] = [b, a]; // tolérance
        if (pageCount && (a > pageCount || b > pageCount)) {
          throw new Error(`Plage hors limites: "${p}" (PDF = ${pageCount} pages)`);
        }
        ranges.push([a, b]);
      }
      return ranges;
    }

    // Create chunk ranges: [[1,N],[N+1,2N],...]
    function buildChunkRanges(pageCount, chunkSize) {
      const n = parseInt(chunkSize, 10);
      if (!Number.isFinite(n) || n <= 0) return null;
      const out = [];
      for (let start = 1; start <= pageCount; start += n) {
        const end = Math.min(pageCount, start + n - 1);
        out.push([start, end]);
      }
      return out;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("Impossible de lire le fichier."));
        r.onload = () => resolve(r.result);
        r.readAsArrayBuffer(file);
      });
    }

    pdfFileEl.addEventListener("change", async () => {
      clearLog();
      const file = pdfFileEl.files?.[0];
      if (!file) {
        pdfBytes = null;
        btnSplitEl.disabled = true;
        return;
      }
      if (file.type !== "application/pdf") {
        log("Le fichier sélectionné n'est pas un PDF.", "err");
        pdfBytes = null;
        btnSplitEl.disabled = true;
        return;
      }
      try {
        pdfName = file.name.replace(/\.pdf$/i, "");
        if (!baseNameEl.value.trim()) baseNameEl.value = pdfName;

        pdfBytes = await readFileAsArrayBuffer(file);
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        log(`PDF chargé: "${file.name}" — ${pdfDoc.getPageCount()} page(s).`, "ok");
        btnSplitEl.disabled = false;
      } catch (e) {
        log(String(e?.message || e), "err");
        pdfBytes = null;
        btnSplitEl.disabled = true;
      }
    });

    btnSplitEl.addEventListener("click", async () => {
      clearLog();
      btnSplitEl.disabled = true;

      try {
        if (!pdfBytes) throw new Error("Aucun PDF chargé.");

        const base = sanitizeBaseName(baseNameEl.value || pdfName);
        const src = await PDFLib.PDFDocument.load(pdfBytes);
        const pageCount = src.getPageCount();

        // Determine ranges
        let ranges = null;
        const rangesText = (rangesEl.value || "").trim();
        if (rangesText) {
          ranges = parseRanges(rangesText, pageCount);
          log(`Mode: Plages (${ranges.length} fichier(s)).`, "ok");
        } else {
          const chunks = buildChunkRanges(pageCount, chunkSizeEl.value);
          if (!chunks) throw new Error("Renseigne soit des plages, soit un N (taille de découpe).");
          ranges = chunks;
          log(`Mode: ${chunkSizeEl.value} pages par fichier (${ranges.length} fichier(s)).`, "ok");
        }

        const zip = new JSZip();

        for (let i = 0; i < ranges.length; i++) {
          const [start, end] = ranges[i];
          const out = await PDFLib.PDFDocument.create();

          const indices = [];
          for (let p = start; p <= end; p++) indices.push(p - 1); // 0-index
          const copied = await out.copyPages(src, indices);
          copied.forEach(pg => out.addPage(pg));

          const bytes = await out.save();

          const fname = `${base}_p${pad3(start)}-${pad3(end)}.pdf`;
          zip.file(fname, bytes);

          log(`✓ Généré: ${fname} (${end - start + 1} page(s))`, "ok");
        }

        log("Création du ZIP…", "warn");
        const zipBlob = await zip.generateAsync({ type: "blob" });
        const zipName = `${base}_split.zip`;
        downloadBlob(zipBlob, zipName);

        log(`Téléchargement lancé: ${zipName}`, "ok");
      } catch (e) {
        log(String(e?.message || e), "err");
      } finally {
        btnSplitEl.disabled = false;
      }
    });
  </script>
</body>
</html>
