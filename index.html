<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Split & Merge PDF (client-side)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="wrap">
    <div class="page-links">
      <a class="nav-link" href="image-to-pdf.html">Convertir des images en PDF →</a>
    </div>

    <h1>Outil HTML — PDF (découper & fusionner)</h1>

    <div class="tool-switch" role="tablist" aria-label="Choisir un outil PDF">
      <button id="btnShowSplit" type="button" aria-pressed="true" data-tool="split">Découper un PDF</button>
      <button id="btnShowMerge" type="button" aria-pressed="false" data-tool="merge">Fusionner des PDFs</button>
      <button id="btnShowCompress" type="button" aria-pressed="false" data-tool="compress">Réduire le poids d’un PDF</button>
    </div>

    <div class="card tool-panel" id="splitPanel">
      <label>1) Choisir un PDF</label>
      <input id="pdfFile" type="file" accept="application/pdf" />

      <div class="row">
        <div class="col">
          <label>2) Mode de découpe</label>
          <div class="hint">
            <b>Option A — Plages</b> : ex. <code>1-3,5,7-9</code> (un fichier par plage / page isolée).<br>
            <b>Option B — Par taille fixe</b> : ex. “10 pages” → 1-10, 11-20, etc.
          </div>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Option A — Plages (prioritaire si rempli)</label>
          <input id="ranges" type="text" placeholder="Ex: 1-3,5,7-9" />
          <div class="hint">Pages 1-indexées (la première page = 1). Espaces autorisés.</div>
        </div>
        <div class="col">
          <label>Option B — Découper tous les N pages</label>
          <input id="chunkSize" type="number" min="1" step="1" placeholder="Ex: 10" />
          <div class="hint">Utilisé uniquement si le champ “Plages” est vide.</div>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Nom de base des fichiers</label>
          <input id="baseName" type="text" placeholder="Ex: document" />
          <div class="hint">Les fichiers seront nommés <code>base_p001-003.pdf</code>, etc.</div>
        </div>
        <div class="col">
          <label>Sortie</label>
          <div class="hint">
            Les PDFs générés sont regroupés dans un <b>ZIP</b> téléchargé automatiquement.
          </div>
        </div>
      </div>

      <button id="btnSplit" disabled>Découper & Télécharger le ZIP</button>

      <pre id="log" aria-live="polite"></pre>

      <div class="footer">
        Libs utilisées côté navigateur : <a href="https://pdf-lib.js.org/" target="_blank" rel="noreferrer">pdf-lib</a> + <a href="https://stuk.github.io/jszip/" target="_blank" rel="noreferrer">JSZip</a>.
      </div>
    </div>

    <div class="card tool-panel is-hidden" id="mergePanel">
      <label>Fusionner plusieurs PDFs</label>
      <input id="mergeFiles" type="file" accept="application/pdf" multiple />

      <div class="row">
        <div class="col">
          <label>Nom du fichier fusionné</label>
          <input id="mergeName" type="text" placeholder="Ex: dossier-final" />
          <div class="hint">Le fichier final portera exactement ce nom (extension .pdf ajoutée si besoin).</div>
        </div>
        <div class="col">
          <label>Sortie</label>
          <div class="hint">Le PDF fusionné est téléchargé automatiquement.</div>
        </div>
      </div>

      <button id="btnMerge" disabled>Fusionner & Télécharger</button>

      <pre id="mergeLog" aria-live="polite"></pre>
    </div>

    <div class="card tool-panel is-hidden" id="compressPanel">
      <label>Réduire le poids d’un PDF (rasterisation)</label>
      <input id="compressFile" type="file" accept="application/pdf" />

      <div class="row">
        <div class="col">
          <label>Nom du fichier compressé</label>
          <input id="compressName" type="text" placeholder="Ex: dossier-leger" />
          <div class="hint">Le fichier final portera exactement ce nom (extension .pdf ajoutée si besoin).</div>
        </div>
        <div class="col">
          <label>Qualité PDF</label>
          <input id="compressQuality" type="range" min="0.7" max="1" step="0.02" value="0.9" />
          <div class="hint">Impacte la clarté des pages (ex: <span id="compressQualityValue">0.90</span>).</div>
        </div>
      </div>

      <button id="btnCompress" disabled>Réduire & Télécharger</button>

      <pre id="compressLog" aria-live="polite"></pre>
    </div>
  </div>

  <!-- pdf-lib -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- pdfjs -->
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <!-- jszip -->
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    const pdfFileEl = $("pdfFile");
    const rangesEl = $("ranges");
    const chunkSizeEl = $("chunkSize");
    const baseNameEl = $("baseName");
    const btnSplitEl = $("btnSplit");
    const logEl = $("log");
    const mergeFilesEl = $("mergeFiles");
    const mergeNameEl = $("mergeName");
    const btnMergeEl = $("btnMerge");
    const mergeLogEl = $("mergeLog");
    const splitPanelEl = $("splitPanel");
    const mergePanelEl = $("mergePanel");
    const compressPanelEl = $("compressPanel");
    const toolButtons = Array.from(document.querySelectorAll("[data-tool]"));
    const compressFileEl = $("compressFile");
    const compressNameEl = $("compressName");
    const compressQualityEl = $("compressQuality");
    const compressQualityValueEl = $("compressQualityValue");
    const btnCompressEl = $("btnCompress");
    const compressLogEl = $("compressLog");

    let pdfBytes = null;
    let pdfName = "document";

    function log(msg, cls="") {
      const prefix = cls ? `[${cls.toUpperCase()}] ` : "";
      logEl.textContent += prefix + msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() { logEl.textContent = ""; }

    function logMerge(msg, cls="") {
      const prefix = cls ? `[${cls.toUpperCase()}] ` : "";
      mergeLogEl.textContent += prefix + msg + "\n";
      mergeLogEl.scrollTop = mergeLogEl.scrollHeight;
    }

    function clearMergeLog() { mergeLogEl.textContent = ""; }

    function logCompress(msg, cls="") {
      const prefix = cls ? `[${cls.toUpperCase()}] ` : "";
      compressLogEl.textContent += prefix + msg + "\n";
      compressLogEl.scrollTop = compressLogEl.scrollHeight;
    }

    function clearCompressLog() { compressLogEl.textContent = ""; }

    function showTool(name) {
      const isSplit = name === "split";
      const isMerge = name === "merge";
      const isCompress = name === "compress";
      splitPanelEl.classList.toggle("is-hidden", !isSplit);
      mergePanelEl.classList.toggle("is-hidden", !isMerge);
      compressPanelEl.classList.toggle("is-hidden", !isCompress);
      toolButtons.forEach((btn) => {
        btn.setAttribute("aria-pressed", String(btn.dataset.tool === name));
      });
    }

    toolButtons.forEach((btn) => {
      btn.addEventListener("click", () => showTool(btn.dataset.tool));
    });

    function sanitizeBaseName(name) {
      const s = (name || "").trim();
      if (!s) return "document";
      const cleaned = s.replace(/[<>:"/\\|?*\u0000-\u001F]/g, "_").slice(0, 80);
      return cleaned.replace(/\.pdf$/i, "");
    }

    function buildPdfName(name, fallback) {
      const base = sanitizeBaseName(name || fallback);
      return `${base}.pdf`;
    }

    function pad3(n) { return String(n).padStart(3, "0"); }

    // Parse "1-3,5,7-9" into array of [start,end] (1-indexed)
    function parseRanges(input, pageCount) {
      const text = (input || "").trim();
      if (!text) return null;

      const parts = text.split(",").map(s => s.trim()).filter(Boolean);
      if (parts.length === 0) return null;

      const ranges = [];
      for (const p of parts) {
        const m = p.match(/^(\d+)(?:\s*-\s*(\d+))?$/);
        if (!m) throw new Error(`Plage invalide: "${p}" (format attendu: 1-3,5,7-9)`);
        let a = parseInt(m[1], 10);
        let b = m[2] ? parseInt(m[2], 10) : a;

        if (a < 1 || b < 1) throw new Error(`Pages doivent être >= 1 (reçu: "${p}")`);
        if (a > b) [a, b] = [b, a]; // tolérance
        if (pageCount && (a > pageCount || b > pageCount)) {
          throw new Error(`Plage hors limites: "${p}" (PDF = ${pageCount} pages)`);
        }
        ranges.push([a, b]);
      }
      return ranges;
    }

    // Create chunk ranges: [[1,N],[N+1,2N],...]
    function buildChunkRanges(pageCount, chunkSize) {
      const n = parseInt(chunkSize, 10);
      if (!Number.isFinite(n) || n <= 0) return null;
      const out = [];
      for (let start = 1; start <= pageCount; start += n) {
        const end = Math.min(pageCount, start + n - 1);
        out.push([start, end]);
      }
      return out;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("Impossible de lire le fichier."));
        r.onload = () => resolve(r.result);
        r.readAsArrayBuffer(file);
      });
    }

    function dataUrlToBytes(dataUrl) {
      const base64 = dataUrl.split(",")[1] || "";
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    function updateRangeValue(el, targetEl) {
      targetEl.textContent = Number(el.value).toFixed(2);
    }

    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    }

    updateRangeValue(compressQualityEl, compressQualityValueEl);

    pdfFileEl.addEventListener("change", async () => {
      clearLog();
      const file = pdfFileEl.files?.[0];
      if (!file) {
        pdfBytes = null;
        btnSplitEl.disabled = true;
        return;
      }
      if (file.type !== "application/pdf") {
        log("Le fichier sélectionné n'est pas un PDF.", "err");
        pdfBytes = null;
        btnSplitEl.disabled = true;
        return;
      }
      try {
        pdfName = file.name.replace(/\.pdf$/i, "");
        if (!baseNameEl.value.trim()) baseNameEl.value = pdfName;

        pdfBytes = await readFileAsArrayBuffer(file);
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        log(`PDF chargé: "${file.name}" — ${pdfDoc.getPageCount()} page(s).`, "ok");
        btnSplitEl.disabled = false;
      } catch (e) {
        log(String(e?.message || e), "err");
        pdfBytes = null;
        btnSplitEl.disabled = true;
      }
    });

    mergeFilesEl.addEventListener("change", async () => {
      clearMergeLog();
      const files = Array.from(mergeFilesEl.files || []);
      if (files.length === 0) {
        btnMergeEl.disabled = true;
        return;
      }
      const invalid = files.find((file) => file.type !== "application/pdf");
      if (invalid) {
        logMerge(`Le fichier "${invalid.name}" n'est pas un PDF.`, "err");
        btnMergeEl.disabled = true;
        return;
      }
      if (!mergeNameEl.value.trim()) {
        mergeNameEl.value = "documents";
      }
      logMerge(`${files.length} PDF(s) prêt(s) à fusionner.`, "ok");
      btnMergeEl.disabled = false;
    });

    compressFileEl.addEventListener("change", async () => {
      clearCompressLog();
      const file = compressFileEl.files?.[0];
      if (!file) {
        btnCompressEl.disabled = true;
        return;
      }
      if (file.type !== "application/pdf") {
        logCompress(`Le fichier "${file.name}" n'est pas un PDF.`, "err");
        btnCompressEl.disabled = true;
        return;
      }
      if (!compressNameEl.value.trim()) {
        compressNameEl.value = file.name.replace(/\.pdf$/i, "");
      }
      logCompress(`PDF prêt pour réduction: "${file.name}".`, "ok");
      btnCompressEl.disabled = false;
    });

    compressQualityEl.addEventListener("input", () => {
      updateRangeValue(compressQualityEl, compressQualityValueEl);
    });

    btnSplitEl.addEventListener("click", async () => {
      clearLog();
      btnSplitEl.disabled = true;

      try {
        if (!pdfBytes) throw new Error("Aucun PDF chargé.");

        const base = sanitizeBaseName(baseNameEl.value || pdfName);
        const src = await PDFLib.PDFDocument.load(pdfBytes);
        const pageCount = src.getPageCount();

        // Determine ranges
        let ranges = null;
        const rangesText = (rangesEl.value || "").trim();
        if (rangesText) {
          ranges = parseRanges(rangesText, pageCount);
          log(`Mode: Plages (${ranges.length} fichier(s)).`, "ok");
        } else {
          const chunks = buildChunkRanges(pageCount, chunkSizeEl.value);
          if (!chunks) throw new Error("Renseigne soit des plages, soit un N (taille de découpe).");
          ranges = chunks;
          log(`Mode: ${chunkSizeEl.value} pages par fichier (${ranges.length} fichier(s)).`, "ok");
        }

        const zip = new JSZip();

        for (let i = 0; i < ranges.length; i++) {
          const [start, end] = ranges[i];
          const out = await PDFLib.PDFDocument.create();

          const indices = [];
          for (let p = start; p <= end; p++) indices.push(p - 1); // 0-index
          const copied = await out.copyPages(src, indices);
          copied.forEach(pg => out.addPage(pg));

          const bytes = await out.save();

          const fname = `${base}_p${pad3(start)}-${pad3(end)}.pdf`;
          zip.file(fname, bytes);

          log(`✓ Généré: ${fname} (${end - start + 1} page(s))`, "ok");
        }

        log("Création du ZIP…", "warn");
        const zipBlob = await zip.generateAsync({ type: "blob" });
        const zipName = `${base}_split.zip`;
        downloadBlob(zipBlob, zipName);

        log(`Téléchargement lancé: ${zipName}`, "ok");
      } catch (e) {
        log(String(e?.message || e), "err");
      } finally {
        btnSplitEl.disabled = false;
      }
    });

    btnMergeEl.addEventListener("click", async () => {
      clearMergeLog();
      btnMergeEl.disabled = true;

      try {
        const files = Array.from(mergeFilesEl.files || []);
        if (files.length === 0) throw new Error("Aucun PDF sélectionné.");

        const out = await PDFLib.PDFDocument.create();
        for (const file of files) {
          const bytes = await readFileAsArrayBuffer(file);
          const src = await PDFLib.PDFDocument.load(bytes);
          const pages = await out.copyPages(src, src.getPageIndices());
          pages.forEach((page) => out.addPage(page));
          logMerge(`Ajouté: ${file.name} (${pages.length} page(s)).`, "ok");
        }

        const mergedBytes = await out.save();
        const mergedName = buildPdfName(mergeNameEl.value, "documents");
        downloadBlob(new Blob([mergedBytes], { type: "application/pdf" }), mergedName);
        logMerge(`Téléchargement lancé: ${mergedName}`, "ok");
      } catch (e) {
        logMerge(String(e?.message || e), "err");
      } finally {
        btnMergeEl.disabled = false;
      }
    });

    btnCompressEl.addEventListener("click", async () => {
      clearCompressLog();
      btnCompressEl.disabled = true;

      try {
        const file = compressFileEl.files?.[0];
        if (!file) throw new Error("Aucun PDF sélectionné.");
        if (!window.pdfjsLib) throw new Error("pdfjs n'est pas disponible.");

        const quality = parseFloat(compressQualityEl.value);
        if (!(quality > 0 && quality <= 1)) throw new Error("Qualité PDF invalide.");
        const scale = 1;

        logCompress("Chargement du PDF…", "warn");
        const bytes = await readFileAsArrayBuffer(file);
        const loadingTask = pdfjsLib.getDocument({ data: bytes });
        const pdf = await loadingTask.promise;
        const out = await PDFLib.PDFDocument.create();

        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const outputViewport = page.getViewport({ scale });
          const renderViewport = page.getViewport({ scale });
          const renderCanvas = document.createElement("canvas");
          renderCanvas.width = Math.max(1, Math.floor(renderViewport.width));
          renderCanvas.height = Math.max(1, Math.floor(renderViewport.height));
          const renderCtx = renderCanvas.getContext("2d", { alpha: false });
          await page.render({ canvasContext: renderCtx, viewport: renderViewport }).promise;

          const dataUrl = renderCanvas.toDataURL("image/jpeg", quality);
          const jpgBytes = dataUrlToBytes(dataUrl);
          const jpgImage = await out.embedJpg(jpgBytes);
          const outPage = out.addPage([jpgImage.width, jpgImage.height]);
          outPage.drawImage(jpgImage, {
            x: 0,
            y: 0,
            width: jpgImage.width,
            height: jpgImage.height,
          });
          logCompress(`Page ${i}/${pdf.numPages} compressée.`, "ok");
        }

        const outBytes = await out.save();
        const outputName = buildPdfName(compressNameEl.value, file.name.replace(/\.pdf$/i, ""));
        downloadBlob(new Blob([outBytes], { type: "application/pdf" }), outputName);
        logCompress(`Téléchargement lancé: ${outputName}`, "ok");
      } catch (e) {
        logCompress(String(e?.message || e), "err");
      } finally {
        btnCompressEl.disabled = false;
      }
    });
  </script>
</body>
</html>
